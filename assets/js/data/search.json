[ { "title": "Windows 11 和 WSL2 安装 CUDA cuDNN OpenCV", "url": "/posts/CUDA-cuDNN-OpenCV/", "categories": "AI, install", "tags": "AI, WSL2, Windows, CUDA, cuDNN, OpenCV", "date": "2023-05-26 17:32:50 +0800", "snippet": "windows 安装安装 CUDACUDA Toolkit Archive NVIDIA Developer我这里下载 cudn 12ps: c c++ windows Visual Studio 较旧的下载 - 2019、2017、2015 和以前的版本 (microsoft.com) Visual Studio 2022 IDE - 适用于软件开发人员的编程工具 (microsof...", "content": "windows 安装安装 CUDACUDA Toolkit Archive NVIDIA Developer我这里下载 cudn 12ps: c c++ windows Visual Studio 较旧的下载 - 2019、2017、2015 和以前的版本 (microsoft.com) Visual Studio 2022 IDE - 适用于软件开发人员的编程工具 (microsoft.com)安装 cuDNNcuDNN Archive NVIDIA Developer环境变量配置CUDA_PATH = C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.1CUDA_PATH_V12_1 = C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.1下载 zlibwapi.dllInstallation Guide NVIDIA Docs放到c:\\windows\\system32下面安装 CMakeDownload CMake这里安装是 3.26安装 openCVopencv_contribopencv这里下载是 4.7.0 cmake-gui.exe 打开配置项目目录是 opencv 所在目录，安装目录自己选着一个 第一次点击 configure 默认就行，点击Finish，第二次点击 configure，开始编译了 configure done 后 search 框内输入 cuda，三个全部 value 打勾 search 框搜 MODULES，在 OPENCV_EXTRA_MODULES_RATH 一项，添加opencv_contrib4.5.1中的modules目录(最好用过 按钮 … 添加) search 框搜 NON， OPENCV_ENABLE_NONFREE value 打勾 search 框搜 world，build_opencv_world 的 value 打勾 search 框搜 test ，BUILD_TESTS ， BUILD_PERF_TESTS ，BUILD_EXAMPLES，去掉打勾 第三次点击 configure search 框内输入 cuda，CUDA_ARCH_BIN 自己显卡的算力 算力查询 第四次点击 confige，然后点击 Generate，然后点击 Open Project，自动启动你的Visual Studio 选择 Release x64，右边解决方案资源管理器 CMakeTargets 下的 ALL_BUILD，右键生成 解决方案资源管理器 CMakeTargets 下的 INSTALL 右键 生成 安装目录 出现一个 install 文件夹 环境变量配置OPENCV_LINK_LIBS = opencv_world470,opencv_img_hash470OPENCV_INCLUDE_PATHS = D:\\App\\opencv\\install\\includeOPENCV_LINK_PATHS = D:\\App\\opencv\\install\\x64\\vc17\\libps: opencv_img_hash470 比较特殊，以前版本是在 opencv_world 里面的，现在独立出来了WSL2 安装更上面一样对应WSL版本，gcc 可能需要更高级版本CUDA： Linux -&gt; x86_64 -&gt;WSL-Ubuntu -&gt; 2.0 -&gt; 看自己喜欢那种方式cuDNN: 安装对应ubuntuWSL2 屏蔽 Windows PATH 方案 ： /etc/wsl.conf 中，设置appendWindowsPath=falseReferenceLinking error on Windows 10 · Issue #360 · twistedfall/opencv-rust · GitHubInstallation Guide - NVIDIA Docs" }, { "title": "mongoDB:unable to wirite wire message network", "url": "/posts/unable-to-wirite-wire-message-network/", "categories": "kubernetes, Istio, Envoy", "tags": "kubernetes, Istio, Envoy, mongoDB, network", "date": "2023-04-27 03:16:00 +0800", "snippet": "起因最近频繁出现mongoDB 写已经关闭的管道 日志[ERROR] conection(1715277-12)unable to wirite wire message network: write tcp 10.311139:40938-&gt;17216.4875:27700:write broken pipe ## Deref 和 DerefMut trait查看 mongoDB 当...", "content": "起因最近频繁出现mongoDB 写已经关闭的管道 日志[ERROR] conection(1715277-12)unable to wirite wire message network: write tcp 10.311139:40938-&gt;17216.4875:27700:write broken pipe ## Deref 和 DerefMut trait查看 mongoDB 当期连接，多出复数连接数，连接程序未知。连接隔一段时间会被 close 掉。 额外的连接 连接隔一段时间会被 close 掉通过看客户端配置连接池是没有设置关闭时间的，怎么会被关闭呢，而且源码里面这种连接也没有心跳维持。问题可能就出在 - 这个程序上了。会不会是 Istio 的呢。直接把 dev 环境的边车去掉后确实没有来。搜了一下看是不是有相关的问题，果真有….Envoy 的 TCPProxy 的 NetworkFilter 的 idle_timeout 参数，默认是 1h。解决方案：改客户端连接池配置 空闲 30分钟的连接自动断掉，Istio 配置就不该了" }, { "title": "ubuntu 22.04 安装 kubernetes 1.26", "url": "/posts/install-kubernetes/", "categories": "kubernetes, install", "tags": "kubernetes, install", "date": "2023-02-25 03:12:00 +0800", "snippet": "初始化 通用#关闭默认dns服务sudo systemctl status systemd-resolvedsudo systemctl stop systemd-resolvedsudo systemctl disable systemd-resolvedecho \"nameserver 8.8.8.8\"|sudo tee /etc/resolv.conf#安装依赖sudo apt-get...", "content": "初始化 通用#关闭默认dns服务sudo systemctl status systemd-resolvedsudo systemctl stop systemd-resolvedsudo systemctl disable systemd-resolvedecho \"nameserver 8.8.8.8\"|sudo tee /etc/resolv.conf#安装依赖sudo apt-get updatesudo apt-get -y install apt-transport-https ipvsadm ipset sysstat conntrack libseccomp-dev ca-certificates curl gnupg lsb-release nfs-kernel-serverhostnamectl set-hostname &lt;主机名字不能是localhost，三主节点不能重复&gt;#查看是否生效hostnamectl status#对应主机名写入hostsecho \"127.0.0.1 xxx\"|sudo tee -a /etc/hostscat &lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.confoverlaybr_netfilterEOFsudo tee etc/modules-load.d/ipvs.conf &lt;&lt; EOFip_vsip_vs_rrip_vs_wrrip_vs_shnf_conntrack #内核小于4.18，把这行改成nf_conntrack_ipv4EOFsudo modprobe ip_vssudo modprobe ip_vs_rrsudo modprobe ip_vs_wrrsudo modprobe ip_vs_shsudo modprobe overlaysudo modprobe br_netfiltercat &lt;&lt; EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.confnet.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1net.bridge.bridge-nf-call-ip6tables = 1net.ipv4.conf.all.proxy_arp = 1EOFsudo sysctl --system# 关闭 防火墙sudo systemctl stop firewalldsudo systemctl disable firewalld# 关闭 SeLinuxsudo setenforce 0sudo sed -i \"s/SELINUX=enforcing/SELINUX=disabled/g\" /etc/selinux/config# 关闭 swapsudo swapoff -asudo cp /etc/fstab /etc/fstab_baksudo sed -ri 's/.*swap.*/#&amp;/' /etc/fstab#三台主节点的ip写入cat &lt;&lt;EOF | sudo tee -a /etc/hosts192.168.122.74 master1192.168.122.110 master2192.168.122.97 master3EOF安装 containerd 官方文档 直接参考安装就好了sudo mkdir /etc/containerdcontainerd config default | sudo tee /etc/containerd/config.tomlsudo sed -i \"s#SystemdCgroup = false#SystemdCgroup = true#g\" /etc/containerd/config.toml#代理配置#[plugins.\"io.containerd.grpc.v1.cri\".registry.mirrors.\"docker.io\"]# endpoint = [\"https://hub-mirror.c.163.com\"]#这个也要修改#sandbox_image = \"registry.aliyuncs.com/google_containers/pause:3.9\"sudo systemctl restart containerd#安装 kubelet kubeadm kubectl#这里使用清华大学源sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpgcat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.listdeb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://mirrors.tuna.tsinghua.edu.cn/kubernetes/apt kubernetes-xenial mainEOFsudo apt-get updatesudo apt-get install -y kubelet kubeadm kubectlsudo systemctl daemon-reloadsudo systemctl enable kubelet &amp;&amp; sudo systemctl start kubeletkubeadm 安装 kubernetes 使用 kubeadm config print init-defaults –component-configs KubeletConfiguration 可以打印集群初始化默认的使用的配置cat &lt;&lt;EOF &gt; ./kubeadm-config.yaml---apiVersion: kubeadm.k8s.io/v1beta3bootstrapTokens:- groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authenticationkind: InitConfigurationlocalAPIEndpoint: advertiseAddress: 192.168.122.74 bindPort: 6443nodeRegistration: criSocket: unix:///run/containerd/containerd.sock imagePullPolicy: IfNotPresent name: master1 # 修改为第一台执行节点的hostname taints: null---controlPlaneEndpoint: 192.168.122.74:6443 # 新增控制平台地址apiServer: timeoutForControlPlane: 4m0sapiVersion: kubeadm.k8s.io/v1beta3certificatesDir: /etc/kubernetes/pkiclusterName: kubernetescontrollerManager: {}dns: {}etcd: local: dataDir: /var/lib/etcdimageRepository: registry.aliyuncs.com/google_containerskind: ClusterConfigurationkubernetesVersion: 1.26.0networking: dnsDomain: cluster.local serviceSubnet: 10.96.0.0/12 podSubnet: 10.100.0.0/16scheduler: {}---apiVersion: kubelet.config.k8s.io/v1beta1kind: KubeletConfigurationcgroupDriver: systemdfailSwapOn: false---apiVersion: kubeproxy.config.k8s.io/v1alpha1kind: KubeProxyConfigurationmode: ipvsEOF#下载镜像sudo kubeadm config images pull --config=kubeadm-config.yaml#初始化 master 其他master不需要sudo kubeadm init --config=kubeadm-config.yaml --upload-certs其他 master 加入集群 kubeadm init phase upload-certs –upload-certskubeadm join 192.168.122.74:6443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:0806c301135d8a0daad21a7474e57888edd12e25de86645eb06e00ecb6e4d565 --control-planenode 节点加入集群 重新创建 token ：kubeadm token create –print-join-commandkubeadm join 192.168.122.74:6443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:0806c301135d8a0daad21a7474e57888edd12e25de86645eb06e00ecb6e4d56安装网络插件calicowget https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/tigera-operator.yamlwget https://raw.githubusercontent.com/projectcalico/calico/v3.25.0/manifests/custom-resources.yamlsudo sed -i \"s#192.168.0.0/16#10.100.0.0/16#\" tigera-operator.yamlsudo sed -i \"s#192.168.0.0/16#10.100.0.0/16#\" custom-resources.yamlkubectl create -f tigera-operator.yamlkubectl create -f custom-resources.yaml#允许master 执行podkubectl taint nodes --all node-role.kubernetes.io/master-kubectl taint nodes --all node-role.kubernetes.io/control-plane-# 恢复默认值kubectl taint nodes NODE_NAME node-role.kubernetes.io/master=true:NoScheduleReference [kubeadm init Kubernetes](https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file) " }, { "title": "k8s pod OOM", "url": "/posts/kuburnetes-pod-cache/", "categories": "kubernetes, excessive_memory_usage, golang", "tags": "kubernetes, excessive_memory_usage, golang", "date": "2022-12-14 19:30:52 +0800", "snippet": "最近线上一个视频服务出现 OOM (4个 pod 其中一个) ,这个服务本身什么有 pprof 。那时候感觉是 BOS SDK 的问题，也看了一下 SDK 的源码。发现内存有 copy 不判断大小直接 copy 来计算大小和 md5 (看 api 说明只需要知道长度就能上传，copy 只是为了计算长度和 md5。直接修改 SDK 代码，一般情况是知道长度，无法获取长度在用循环读取方式计算)。...", "content": "最近线上一个视频服务出现 OOM (4个 pod 其中一个) ,这个服务本身什么有 pprof 。那时候感觉是 BOS SDK 的问题，也看了一下 SDK 的源码。发现内存有 copy 不判断大小直接 copy 来计算大小和 md5 (看 api 说明只需要知道长度就能上传，copy 只是为了计算长度和 md5。直接修改 SDK 代码，一般情况是知道长度，无法获取长度在用循环读取方式计算)。也给服务挂上 pprof 。重新部署上线后 发现还是有一个 pod 异常，内存占用很高(第一感觉内存泄漏？)….进入容器内部查看实际占用只有 200M 左右( cat /proc/1/status )这就很奇怪，pprof 看起来也很正常。于是乎感觉是使用内存计算不一样？google 一下发现确实是这样 cache 使用也被算上了(但是也不应该调整 Linux 策略)。但是还是不太多只有一个 pod 异常。那这是变成负载均衡策略问题(轮询)，统计ELK 日志发现确实视频接收时候有可能大部分落在一个节点上( istio 再添加针对单个接口的负载均衡策略)ps:上面这个搞了几天，虽然问题不大。但是定位很崎岖…" }, { "title": "WSL2 开启 KVM 并创建虚拟机", "url": "/posts/wsl2-%E8%99%9A%E6%8B%9F%E6%9C%BA/", "categories": "WSL2, KVM", "tags": "WSL2, KVM", "date": "2022-04-11 09:42:06 +0800", "snippet": "WSL2(AMD 上的 Hyper-V 嵌套虚拟化先决条件要求主机操作系统是 Windows 2022 或 Windows 11) 使用过的是 Ubuntu 20.04 LTS更换内核安装编译环境sudo apt update &amp;&amp; sudo apt -y upgradesudo apt -y install make gcc build-essential libncurs...", "content": "WSL2(AMD 上的 Hyper-V 嵌套虚拟化先决条件要求主机操作系统是 Windows 2022 或 Windows 11) 使用过的是 Ubuntu 20.04 LTS更换内核安装编译环境sudo apt update &amp;&amp; sudo apt -y upgradesudo apt -y install make gcc build-essential libncurses-dev bison flex libssl-dev libelf-dev cpu-checker qemu-kvm aria2 使用微软 WSL2 专用[内核源码](https://github.com/microsoft/WSL2-Linux-Kernel)wget https://github.com/microsoft/WSL2-Linux-Kernel/archive/refs/tags/linux-msft-wsl-5.10.74.3.tar.gztar -zxvf linux-msft-wsl-5.10.74.3.tar.gzcd WSL2-Linux-Kernel-linux-msft-wsl-5.10.74.3使用当前系统配置zcat /proc/config.gz &gt; .configmake menuconfig在 Virtualization中确认 Intel 支持已被选中，virtio-net 也被选中按两次 ESC Processor type and features -&gt; Linux guest support，选中 KVM Guest support编译make -j 8使用新内核新内核放到 windows 这边 并修改配置cp arch/x86/boot/bzImage /mnt/c/Users/&lt;username&gt;/bzImagevi /mnt/c/Users/&lt;username&gt;/.wslconfig配置参考官方文档 ： 主要还是 kernelCommandLine 和 kernel[wsl2]nestedVirtualization=truememory=48GBswap=0localhostForwarding=true#英特尔 kernelCommandLine=intel_iommu=on iommu=pt kvm.ignore_msrs=1 kvm-intel.nested=1 kvm-intel.ept=1 kvm-intel.emulate_invalid_guest_state=0 kvm-intel.enable_shadow_vmcs=1 kvm-intel.enable_apicv=1kernelCommandLine=amd_iommu=on iommu=pt kvm.ignore_msrs=1 kvm-amd.nested=1 kvm-amd.ept=1 kvm-amd.emulate_invalid_guest_state=0 kvm-amd.enable_shadow_vmcs=1 kvm-amd.enable_apicv=1kernel=C:\\\\Users\\\\&lt;username&gt;\\\\bzImage重新启动 WSL 2打开 powershell 根据自己发行版名字调整(wsl –list)wsl --shutdown Ubuntu-20.04 uname -ar #查看内核版本 kvm-ok #kvm是否可用 #INFO: /dev/kvm exists #KVM acceleration can be used开启 systemd|2023年2月3日 16:51:33 已过时|最新 wsl2 支持，/etc/wsl.conf[boot]systemd=true使用 genie安装文档参考官方 wsl2 1.0 支持systemdgenie -s#Waiting for systemd....!!!#第一次启动会很长，等待它结束会输出错误#错误参考 https://github.com/arkane-systems/genie/wiki/Systemd-units-known-to-be-problematic-under-WSL安装使用virsh qemu-kvm 包含 KVM 的用户空间（Userspace）态组件； libvirt* 打头的包内置用于管理虚拟化平台的工具； bridge-utils 包含用于配置宿主机与虚拟机之间网络连结的工具； virtinst 包含命令行版本的用于创建虚拟机的工具； cloud-image-utils 包含用于解析 cloud-init 格式文件的工具（稍后用到！）； virt-manager 包内置用于创建和管理虚拟机的 GUI 工具。 sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst cloud-image-utils virt-manager -y需要添加当前用户到 libvirt 以及 kvm 组中sudo adduser `id -un` libvirtsudo adduser `id -un` kvm查看是否运行virsh list --all# Id Name State#----------------------------------网络我是使用默认的可以参考这里创建VM使用的是img 格式的镜像启动 VM ubuntu-20.04-server-cloudimg-amd64.img 体积比较小。查看镜像信息qemu-img info ubuntu-20.04-server-cloudimg-amd64.img#image: ubuntu-20.04-minimal-cloudimg-amd64.img#file format: qcow2#virtual size: 2.2 GiB (2361393152 bytes)#disk size: 199 MiB#cluster_size: 65536#Format specific information:#compat: 0.10#refcount bits: 16镜像默认空间很小，调整到自己喜欢的大小qemu-img resize ubuntu-20.04-minimal-cloudimg-amd64.img 25GCloud-init 是适用于多种发行版镜像初始化任务的工业级别标准。该文件描述了将发行版镜像初始化为 VM 实例中的一些行为。教程简单的 cloud-init 文件如下，默认用户（ubuntu）创建了同名密码#cloud-configpassword: ubuntuchpasswd: { expire: False }ssh_pwauth: Truehostname: ubuntucloud-localds 实用工具（位于 cloud-image-utils 包中）用于通过给定的 cloud-init 格式的文本文件生成对应的 .iso 初始化镜像。cloud-localds /var/lib/libvirt/images/install.iso cloud.txt其中，/var/lib/libvart/images/ 是 virsh 实用工具保存 VM 磁盘的默认路径，把上面img copy 到这里(创建多个VM需要cp多个)cp ubuntu-20.04-server-cloudimg-amd64.img /var/lib/libvirt/images/ubuntu1.img创建虚拟机virt-install --name vm1 --ram=2048 --vcpus 1 \\--os-variant ubuntu20.04 --graphics none \\--disk /var/lib/libvirt/images/ubuntu1.img,device=disk,bus=virtio \\--disk /var/lib/libvirt/images/install.iso,device=cdrom --importtips WSL2 使用桥接 issue ，不过每次开机删掉永远定义的虚拟交换机，重建后还会出现网络问题(网络慢，wife)，还需要重启一下网络适配器….WSL2-1.0C:\\Users\\~\\.wslconfig[wsl2]networkingMode = bridgedvmSwitch = Bridged //hyper-v 里面的桥接器名字dhcp = falsenestedVirtualization=truememory=48GBswap=0ipv6=true#localhostForwarding=true cd /lib/systemd/network/ 创建并编辑一个新文件： nano wsl_external.network[Match]Name=eth0[Network]Description=WSL_externalDHCP=trueIPv6AcceptRA=trueMulticastDNS=trueLLDP=trueEmitLLDP=true[DHCP]CriticalConnection=trueRouteMetric=10UseDomains=truesudo systemctl restart systemd-networkdsudo systemctl enable systemd-networkd /etc/wsl.conf文件[boot]systemd=true[network]generateResolvConf = false## 修改 /etc/resolv.conf nameserver 8.8.8.8sudo systemctl restart systemd-resolved.servicesudo systemctl enable systemd-resolved.service参考 基于 Ubuntu 20.04 系统使用 KVM+CloudInit 创建虚拟机 – DGideas' Blog Accelerated KVM guests on WSL 2 " }, { "title": "Rust async/await", "url": "/posts/Rust-tokio/", "categories": "Rust, 异步并发, async/await, (1)", "tags": "Rust, 异步并发, async/await", "date": "2022-04-09 16:23:10 +0800", "snippet": "最近看来一篇 async/await 文章，做一下总结#[inline(never)]async fn x() -&gt; usize { 5}等价代码：#[inline(never)]fn x() -&gt; impl Future&lt;Output = usize&gt; { async { 5 }}async fn 就是会返回一个 Future trait 的函数，fut...", "content": "最近看来一篇 async/await 文章，做一下总结#[inline(never)]async fn x() -&gt; usize { 5}等价代码：#[inline(never)]fn x() -&gt; impl Future&lt;Output = usize&gt; { async { 5 }}async fn 就是会返回一个 Future trait 的函数，future 是惰性的，想要运行需要 .await 或者其他运行时。调用其 poll 方法获取 Future 的运行结果（GeneratorState） yield 进行让出执行权直到状态就绪#[lang = \"from_generator\"]#[doc(hidden)]#[unstable(feature = \"gen_future\", issue = \"50547\")]#[rustc_const_unstable(feature = \"gen_future\", issue = \"50547\")]#[inline]pub const fn from_generator&lt;T&gt;(gen: T) -&gt; impl Future&lt;Output = T::Return&gt;where T: Generator&lt;ResumeTy, Yield = ()&gt;,{ #[rustc_diagnostic_item = \"gen_future\"] struct GenFuture&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt;(T); // We rely on the fact that async/await futures are immovable in order to create // self-referential borrows in the underlying generator. impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; !Unpin for GenFuture&lt;T&gt; {} impl&lt;T: Generator&lt;ResumeTy, Yield = ()&gt;&gt; Future for GenFuture&lt;T&gt; { type Output = T::Return; fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; { // SAFETY: Safe because we're !Unpin + !Drop, and this is just a field projection. let gen = unsafe { Pin::map_unchecked_mut(self, |s| &amp;mut s.0) }; // Resume the generator, turning the `&amp;mut Context` into a `NonNull` raw pointer. The // `.await` lowering will safely cast that back to a `&amp;mut Context`. match gen.resume(ResumeTy(NonNull::from(cx).cast::&lt;Context&lt;'static&gt;&gt;())) { GeneratorState::Yielded(()) =&gt; Poll::Pending, GeneratorState::Complete(x) =&gt; Poll::Ready(x), } } } GenFuture(gen)}参考 [iPotato Rust 的 async/await 语法是怎样工作的](https://ipotato.me/article/70) " }, { "title": "Rust 生命周期理解", "url": "/posts/Rust-life-cycle/", "categories": "Rust, 生命周期", "tags": "Rust, 生命周期", "date": "2022-03-31 10:32:00 +0800", "snippet": "Rust 生命周期消除规则： 每一个引用参数都会获得独自的生命周期 fn foo(x: &amp; i32, y: &amp;i32){}//两个函数代码是等价fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32){//独立的生命周期}//如果返回值是其中的某个参数，编译器不清楚返回那个生命周期 ...", "content": "Rust 生命周期消除规则： 每一个引用参数都会获得独自的生命周期 fn foo(x: &amp; i32, y: &amp;i32){}//两个函数代码是等价fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32){//独立的生命周期}//如果返回值是其中的某个参数，编译器不清楚返回那个生命周期 若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期 fn foo(x: &amp;i32) -&gt; &amp;i32{}//两个函数代码是等价fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32{} 若存在多个输入生命周期，且其中一个是 &amp;self 或 &amp;mut self，则 &amp;self 的生命周期被赋给所有的输出生命周期 impl&lt;'a&gt; test&lt;'a&gt;{ fn foo&lt;'b&gt;(&amp;'a self,s:&amp;'b str)-&gt;&amp;'a str{}}//等价与下面函数impl test{ fn foo(&amp; self,s:&amp; str)-&gt;&amp; str{ }} NLL(Non-Lexical Lifetime) 应用的声明周期从借用处开始到最后一次使用的地方(rust 从 1.31 版本开始)Reborrow 再借用 可以通过 &amp;*v 进行再次借用，再借用生命周期内不能使用 v 的可变借用let mut s = String::from(\"test\");let a = &amp;mut s;let aa = &amp;*a;//这里不能使用 a 的可变借用，但是可以使用不可变借用println!(\"{}\",aa);//aa的声明周期结束 NLL 规则println!(\"{}\",a);’static 静态生命周期直到程序终止&amp;‘ static 和 ’static 一样，但是他是针对引用 (fn foo&lt; T: ‘static&gt;( var: &amp; T) 这样就是相等的 )" }, { "title": "Rust std(3) string", "url": "/posts/Rust-string/", "categories": "Rust, std, string", "tags": "Rust, std, string", "date": "2021-09-17 19:22:10 +0800", "snippet": "use std :: string :: String *with_capacity(capacity: usize) -&gt; String 创建一个指定容量的string into_raw_parts(self) -&gt; (*mut u8, usize, usize) 分解一个string内部数据返回 into_bytes(self) -...", "content": "use std :: string :: String *with_capacity(capacity: usize) -&gt; String 创建一个指定容量的string into_raw_parts(self) -&gt; (*mut u8, usize, usize) 分解一个string内部数据返回 into_bytes(self) -&gt; Vec&lt;u8, Global&gt; 字符串转换u8 vector *as_str(&amp;self) -&gt; &amp;str 返回借用 *as_mut_str(&amp;mut self) -&gt; &amp;mut str 返回可变借用 *push_str(&amp;mut self, string: &amp;str) 追加字符 extend_from_within(&amp;mut self, src: R) 追加指定字符(extend_from_within(2..)) *capacity(&amp;self) -&gt; usize 返回字符串cap *reserve(&amp;mut self, additional: usize) 重新设置 cap(最后比原来的大) reserve_exact(&amp;mut self, additional: usize) 额外追加 cap try_reserve(&amp;mut self, additional: usize) -&gt; Result&lt;(), TryReserveError&gt; 额外追加 self.len() + additional 不大于cap 不返回错误 try_reserve_exact( &amp;mut self, additional: usize ) -&gt; Result&lt;(), TryReserveError&gt; *shrink_to_fit(&amp;mut self) cap缩容到len长度 shrink_to(&amp;mut self, min_capacity: usize) truncate(&amp;mut self, new_len: usize) 缩容到指定长度 截取掉 *push(&amp;mut self, ch: char) 插入字符 *pop(&amp;mut self) -&gt; Option 弹出字符 *as_bytes(&amp;self) -&gt; &amp;[u8] 转换bytes remove(&amp;mut self, idx: usize) -&gt; char 返回指定下标字符 *retain(&amp;mut self, f: F) 保留返回 闭包true 字符 *insert(&amp;mut self, idx: usize, ch: char) 指定赋值下标字符 insert_str(&amp;mut self, idx: usize, string: &amp;str) *len(&amp;self) -&gt; usize 长度 *is_empty(&amp;self) -&gt; bool 如果该字符串的长度为0，则返回true，否则返回false。 split_off(&amp;mut self, at: usize) -&gt; String 保留 [0, at) 返回 [at, len) clear(&amp;mut self) 清空 len 长度 drain(&amp;mut self, range: R) -&gt; Drain&lt;'_&gt; 迭代器删除指定字符 .collect(); 执行 replace_range(&amp;mut self, range: R, replace_with: &amp;str) 查找替换字符串 into_boxed_str(self) -&gt; Box&lt;str, Global&gt; 字符串装箱 str(部分 有些重复的就不写了) is_char_boundary(&amp;self, index: usize) -&gt; bool 检查指定字符是否符合UTF-8 code as_ptr(&amp;self) -&gt; *const u8 原始u8 指针 get(&amp;self, i: I) -&gt; Option&lt;&amp;&lt;I as SliceIndex&gt;::Output&gt; 获取借用 get_mut( &amp;mut self, i: I ) -&gt; Option&lt;&amp;mut &lt;I as SliceIndex&gt;::Output&gt; 获取可变借用 split_at(&amp;self, mid: usize) -&gt; (&amp;str, &amp;str) 分割字符串 chars(&amp;self) -&gt; Chars&lt;’_&gt; 字符切片迭代器 char_indices(&amp;self) -&gt; CharIndices&lt;’_&gt; 字符与位置迭代器 bytes(&amp;self) -&gt; Bytes&lt;’_&gt; 二进制迭代器 split_whitespace(&amp;self) -&gt; SplitWhitespace&lt;’_&gt; 空格迭代 split_ascii_whitespace(&amp;self) -&gt; SplitAsciiWhitespace&lt;’_&gt; 单空格 lines(&amp;self) -&gt; Lines&lt;’_&gt; 换行符迭代 contains&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; bool 匹配是否一致 starts_with&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; bool 匹配开始的字符 ends_with&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; bool 结束的字符 find&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; Option 查找字符 返回位置 rfind&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; Option 从后面开始找 split&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; Split&lt;’a, P&gt; 字符串分割 let v: Vec&lt;&amp;str&gt; = “Mary had a little lamb”.split(‘ ‘).collect(); split_inclusive&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; SplitInclusive&lt;’a, P&gt; 包含分隔符 split_terminator&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; SplitTerminator&lt;’a, P&gt; 去空 splitn&lt;’a, P&gt;(&amp;’a self, n: usize, pat: P) -&gt; SplitN&lt;’a, P&gt; 查找几次 split_once&lt;’a, P&gt;(&amp;’a self, delimiter: P) -&gt; Option&lt;(&amp;’a str, &amp;’a str)&gt; 查找一次 matches&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; Matches&lt;’a, P&gt; 迭代指定字符 pat 返回都是pat match_indices&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; MatchIndices&lt;’a, P&gt; 返回位置信息 trim(&amp;self) -&gt; &amp;str 去空 trim_matches&lt;’a, P&gt;(&amp;’a self, pat: P) -&gt; &amp;’a str 去除指定字符 strip_prefix&lt;’a, P&gt;(&amp;’a self, prefix: P) -&gt; Option&lt;&amp;’a str 去除指定前缀 parse(&amp;self) -&gt; Result&lt;F, ::Err&gt; 转换类型 is_ascii(&amp;self) -&gt; bool 是否是ascii eq_ignore_ascii_case(&amp;self, other: &amp;str) -&gt; bool 大小写忽略匹配 replace&lt;’a, P&gt;(&amp;’a self, from: P, to: &amp;str) -&gt; String 查找替换返回string replacen&lt;’a, P&gt;(&amp;’a self, pat: P, to: &amp;str, count: usize) -&gt; String 查找替换加次数 to_lowercase(&amp;self) -&gt; String 小写 to_uppercase(&amp;self) -&gt; String 大写 repeat(&amp;self, n: usize) -&gt; String 重复字符串 多少次 " }, { "title": "Rust std(2) vertor", "url": "/posts/Rust-vertor/", "categories": "Rust, std, vertor", "tags": "Rust, std, vertor", "date": "2021-09-12 13:32:00 +0800", "snippet": "常用with_capacity(capacity: usize) -&gt; Vec&lt;T, Global&gt;设置 cap 返回 veccapacity(&amp;self) -&gt; usize获取容量 capappend(&amp;mut self, other: &amp;mut Vec&lt;T, A&gt;)pop(&amp;mut self) -&gt; Optionp...", "content": "常用with_capacity(capacity: usize) -&gt; Vec&lt;T, Global&gt;设置 cap 返回 veccapacity(&amp;self) -&gt; usize获取容量 capappend(&amp;mut self, other: &amp;mut Vec&lt;T, A&gt;)pop(&amp;mut self) -&gt; Optionpush(&amp;mut self, value: T)reserve(&amp;mut self, additional: usize)clear(&amp;mut self)len(&amp;self) -&gt; usizeis_empty(&amp;self) -&gt; booltry_reserve(&amp;mut self, additional: usize) -&gt; Result&lt;(), TryReserveError&gt;为在给定的Vec中插入至少更多的元素保留容量.大于self.len() + reserve， 如果容量已经足够，则什么也不做reserve_exact(&amp;mut self, additional: usize)try_reserve_exact( &amp;mut self, additional: usize ) -&gt; Result&lt;(), TryReserveError&gt;预留最小容量 reserve_exact，在调用 reserve_exact 之后，容量将大于或等于 self.len() + reserve_exact， 如果容量已经足够，则什么也不做。shrink_to_fit (&amp;mut self)缩容(由系统决定缩容值)shrink_to (&amp;mut self, min_capacity: usize )指定缩容，如果没有足够的空间就不做操作into_boxed_slice (self) -&gt; Box &lt; [ T ] , A&gt;将向量转换为Box&lt;[T]&gt;. 请注意，这将减少任何多余的容量。truncate(&amp;mut self, len: usize)保留第一个len元素并删除其余元素,如果len大于向量的当前长度，则无效。cap不影响as_slice (&amp;self) -&gt; &amp;[T]提取包含整个 vec 的切片。相当于&amp;s[..]as_mut_slice (&amp;mut self) -&gt; &amp;mut [T]提取整个向量的可变切片。 相当于&amp;mut s[..]swap_remove(&amp;mut self, index: usize) -&gt; To(1) 不保留排序，index 超出范围会 paincremove(&amp;mut self, index: usize) -&gt; T移除并返回矢量中索引位置的元素，将其之后的所有元素向左移动。O(n)insert(&amp;mut self, index: usize, element: T)指定位置插入元素retain(&amp;mut self, f: F) where F: FnMut(&amp;T) -&gt; bool遍历元素 根据函数返回 true 进行保留retain_mut(&amp;mut self, f: F) where F: FnMut(&amp;mut T) -&gt; bool遍历元素 跟 retain 一样true 保留dedup_by_key&lt;F, K&gt;(&amp;mut self, key: F) where F: FnMut(&amp;mut T) -&gt; K, K: PartialEq删除向量中解析为相同键的所有连续元素，但第一个元素除外。如果向量已排序，则会删除所有重复项(连续元素)。dedup_by(&amp;mut self, same_bucket: F) where F: FnMut(&amp;mut T, &amp;mut T) -&gt; bool( next , current) true 删除 next ，flase 保留drain(&amp;mut self, range: R) -&gt; Drain&lt;'_, T, A&gt;ⓘ where R: RangeBounds从向量中批量移除指定的范围，并将所有移除的元素作为一个迭代器返回。如果迭代器在被完全消耗之前被丢弃，它会丢弃剩余的移除元素。let u: Vec&lt;_&gt; = v.drain(1..).collect();split_off(&amp;mut self, at: usize) -&gt; Vec&lt;T, A&gt;返回一个新分配的向量，包含范围[at, len]内的元素。调用后，原向量将被留下，包含元素[0, at]，其先前的容量没有改变 。resize(&amp;mut self, new_len: usize, value: T)调整Vec的大小，使len等于new_len如果new_len大于len，则Vec被扩展，每一个额外的槽被填满。如果new_len小于len，那么Vec就被简单地截断了。resize_with(&amp;mut self, new_len: usize, f: F) where F: FnMut() -&gt; T如果new_len大于len，那么Vec被扩展，每一个额外的槽都被调用闭包f的结果所填充。如果new_len小于len，Vec将被简单地截断。Default::default 可以作为第二个参数leak&lt;’a&gt;(self) -&gt; &amp;’a mut [T]泄漏可变vec。从Rust 1.57开始，这个方法不会重新分配或缩小Vec，所以泄露的分配可能包括未使用的容量，而这些容量不属于返回的片断。spare_capacity_mut(&amp;mut self) -&gt; &amp;mut [MaybeUninit]返回cap容量可修改，可以配合set_len 使用as_ptr (&amp;self) -&gt; *const Tas_mut_ptr(&amp;mut self) -&gt; *mut T###不常用unsafe fn from_raw_parts( ptr: *mut T, length: usize, capacity: usize ) -&gt; Vec&lt;T, Global&gt;unsafe 根据 数据源地址，len ，cap 进行设置 vecunsafe fn set_len(&amp;mut self, new_len: usize)必须小于等于 capleak&lt;’a&gt;(self) -&gt; &amp;’a mut [T]消耗并泄露Vec，返回对其内容的可变引用，&amp;’a mut [T]。注意，类型T必须超过所选择的生命周期’a’。如果该类型只有静态引用，或者根本没有，那么可以选择 “静态”。从Rust 1.57开始，这个方法不会重新分配或缩小Vec，所以泄露的分配可能包括未使用的容量，而这些容量不属于返回的片断。spare_capacity_mut(&amp;mut self) -&gt; &amp;mut [MaybeUninit]返回向量的剩余容量，作为 MaybeUninit的一个片断。在使用set_len方法将数据标记为初始化之前，返回的片断可以用来向向量中填充数据（例如从文件中读取）。// Allocate vector big enough for 10 elements.let mut v = Vec::with_capacity(10);// Fill in the first 3 elements.let uninit = v.spare_capacity_mut();uninit[0].write(0);uninit[1].write(1);uninit[2].write(2);// Mark the first 3 elements of the vector as being initialized.unsafe { v.set_len(3);}assert_eq!(&amp;v, &amp;[0, 1, 2]);split_at_spare_mut(&amp;mut self) -&gt; (&amp;mut [T], &amp;mut [MaybeUninit])将vec的内容作为T的一个片断返回，同时将vec的剩余容量作为 MaybeUninit的一个片断返回。extend_from_slice(&amp;mut self, other: &amp;[T])遍历vec元素追到调用的vec里" }, { "title": "Rust std(1) Iterator", "url": "/posts/Rust-Iterator/", "categories": "Rust, std, Iterator", "tags": "Rust, std, Iterator", "date": "2021-09-11 13:32:00 +0800", "snippet": "这几天写算法题发现自己对标准库熟悉度是非常的低。所以加强一下。常用next迭代器的下一个元素返回 Optionlet i = [1, 2, 3];let s = vec![\"1\",\"2\",\"3\"];let v:Vec&lt;i32&gt; = Vec::new();println!(\"{:?}--{:?}--{:?}\",i.iter().next(),s.iter().next(),v.it...", "content": "这几天写算法题发现自己对标准库熟悉度是非常的低。所以加强一下。常用next迭代器的下一个元素返回 Optionlet i = [1, 2, 3];let s = vec![\"1\",\"2\",\"3\"];let v:Vec&lt;i32&gt; = Vec::new();println!(\"{:?}--{:?}--{:?}\",i.iter().next(),s.iter().next(),v.iter().next());//Some(1)--Some(\"1\")--Nonecollect执行迭代器nth返回迭代器第n个元素，且迭代器也会从这里进行 nextlet s = vec![\"1\",\"2\",\"3\"];let mut si = s.iter();println!(\"{:?}\",si.nth(1));println!(\"{:?}\",si.next());//Some(\"2\")//Some(\"3\")skip迭代器跳到指定位置，跟 nth 的区别是不返回跳到的元素rev反向迭代take创建一个迭代器 指定元素迭代最大个数scan一个初始值，它是内部状态的种子，以及一个有两个参数的闭包，第一个是对内部状态的可变引用，第二个是迭代器元素chain链接2个迭代器形成链表let s1 = &amp;[1, 2, 3];let s2 = &amp;[4, 5, 6];let mut iter = s1.iter().chain(s2);assert_eq!(iter.next(), Some(&amp;1));assert_eq!(iter.next(), Some(&amp;2));assert_eq!(iter.next(), Some(&amp;3));assert_eq!(iter.next(), Some(&amp;4));zip链接2个迭代器形成同时迭代，任何一个迭代器多出来元素忽略掉let a1 = [1, 2, 3,7];let a2 = [4, 5, 6];let mut iter = a1.iter().zip(a2.iter());assert_eq!(iter.next(), Some((&amp;1, &amp;4)));assert_eq!(iter.next(), Some((&amp;2, &amp;5)));assert_eq!(iter.next(), Some((&amp;3, &amp;6)));println!(\"{:?}\",iter.next());//Noneunziplet a = [(1, 2), (3, 4), (5, 6)];let (left, right): (Vec&lt;_&gt;, Vec&lt;_&gt;) = a.iter().cloned().unzip();assert_eq!(left, [1, 3, 5]);assert_eq!(right, [2, 4, 6]);// you can also unzip multiple nested tuples at oncelet a = [(1, (2, 3)), (4, (5, 6))];let (x, (y, z)): (Vec&lt;_&gt;, (Vec&lt;_&gt;, Vec&lt;_&gt;)) = a.iter().cloned().unzip();assert_eq!(x, [1, 4]);assert_eq!(y, [2, 5]);assert_eq!(z, [3, 6]);copied实现 copy 进行复制cloned实现 clone 进行复制map对迭代器进行闭包调用，惰性的flat_mapmap 的闭包为每个元素返回一个处理后的元素，而 flat_map() 的闭包为每个元素返回一个迭代器。类似 map(f).flatten()flatten相当于把 2 层迭代器或2可以迭代的变成一层let d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]];let d2 = d3.iter().flatten().collect::&lt;Vec&lt;_&gt;&gt;();assert_eq!(d2, [&amp;[1, 2], &amp;[3, 4], &amp;[5, 6], &amp;[7, 8]]);let d1 = d3.iter().flatten().flatten().collect::&lt;Vec&lt;_&gt;&gt;();assert_eq!(d1, [&amp;1, &amp;2, &amp;3, &amp;4, &amp;5, &amp;6, &amp;7, &amp;8]);fuse创建一个迭代器，在第一个None之后结束filter迭代器闭包过滤是否输出 truefilter_map相当于 map().filter().map() 其实就是帮你解多一层enumerate创建迭代器 返回值 (序号，值)peekable创建一个迭代器 peek 和peek_mut 不消耗迭代次数 nextskip_while忽略闭包返回 true 的元素，第一次返回 flase 就不在调用take_while返回闭包返回 true 的元素，第一次返回 flase 就不在调用map_while相当于 take_while 自动解应用返回 Some(4)for_each跟map 差不多，但是它不是惰性的，且无返回值foldfold() 需要两个参数：一个初始值，和一个有两个参数的闭包：一个’累加器’，和一个元素。闭包返回累加器在下一次迭代时应具有的值reducereduce() 相比 fold 少了一个初始值max查找迭代器最大值min查找迭代器最小值try_fold闭包一个初始值，以及一个有两个参数的闭包：一个 “累加器 “和一个元素。闭包要么成功返回，为下一次迭代提供累加器的值，要么返回失败，提供一个错误值。返回错误的迭代会停止，剩下不会进行迭代，返回值为 nonelet a = [10, 20, 30, 100, 40, 50];let mut it = a.iter();let sum = it.try_fold(0i8, |acc, &amp;x| acc.checked_add(x));assert_eq!(sum, None);assert_eq!(it.len(), 2);assert_eq!(it.next(), Some(&amp;40));try_for_each第一个错误处停止并返回该错误for_each() 的易变形式，或者是 try_fold() 的无状态版本use std::fs::rename;use std::io::{stdout, Write};use std::path::Path;let data = [\"no_tea.txt\", \"stale_bread.json\", \"torrential_rain.png\"];let res = data.iter().try_for_each(|x| writeln!(stdout(), \"{}\", x));assert!(res.is_ok());let mut it = data.iter().cloned();let res = it.try_for_each(|x| rename(x, Path::new(x).with_extension(\"old\")));assert!(res.is_err());// It short-circuited, so the remaining items are still in the iterator:assert_eq!(it.next(), Some(\"stale_bread.json\"));inspect对迭代器的每个元素进行处理，并将值传递给它。 一般作为调试调用by_ref借用一个迭代器，可变借用partition通过闭包将迭代器变成 2 个集合 一个 true 元素合集， 一个 false 元素合集is_partitioned() 和 partition_in_place(）单独返回allall() 接收一个返回真或假的闭包，并执行迭代返回 全部元素为 true 返回 true (消耗迭代器次数，返回 false )let a = [1, 2, 3];let mut iter = a.iter();println!(\"{:?}\",iter.all(|&amp;x| x != 2));println!(\"{:?}\",iter.next());//false//Some(3)any和 all 相反 返回 flase 继续find搜索一个元素，找到返回元素，闭包参数是一个双重引用find_mapf 提供返回值为Some(value) ，map 只能是值相当于 iter.filter_map(f).next() 。filter_map 不执行迭代器，find_map 执行迭代器position搜索迭代器的元素返回索引(会消耗迭代器)rposition搜索迭代器的元素返回索引(会消耗迭代器，从右开始)sum求和product乘法求乘积 溢出会 painccmp两个迭代器比较是否相等 (cmp_by nightly-only)use std::cmp::Ordering;assert_eq!([1].iter().cmp([1].iter()), Ordering::Equal);assert_eq!([1].iter().cmp([1, 2].iter()), Ordering::Less);assert_eq!([1, 2].iter().cmp([1].iter()), Ordering::Greater);eq和另一个迭代器进行比较(大小和迭代器个数相等)(eq_by nightly-only)ne和另一个迭代器进行比较 不等 返回truelt小于le小于等于ge大于gt大于等于is_sorted是否已经排序 要实现 PartialOrd （nightly-only is_sorted_by is_sorted_by_key）不常用size_hint返回迭代器当前剩余的元素，返回类型元组(usize 当前剩余元素,usize上限)let s = vec![\"1\",\"2\",\"3\"];let mut si = s.iter();si.next();println!(\"{:?}\",si.size_hint());//(2, Some(2))count返回迭代器还有多少个未迭代的元素let s = vec![\"1\",\"2\",\"3\"];let mut si = s.iter();si.next();println!(\"{:?}\",si.count());last消耗迭代器返回最后一个元素let s = vec![\"1\",\"2\",\"3\"];let mut si = s.iter();si.next();println!(\"{:?}\",si.last());//Some(\"3\")advance_by迭代器推进n个元素 （nightly-only）```rustlet s = vec![\"1\",\"2\",\"3\"];let mut si = s.iter();si.advance_by(2);println!(\"{:?}\",si.next());//Some(\"3\")### step_by调整迭代器的步长(原本为1)### intersperse_with迭代器添加偶数分割返回```rustiter.intersperse_with(|| 99);try_collectnightly-onlymax_by_key返回最大值(多个是相同最大值是最后一个)，参数是闭包可以进行筛选min_by_key跟 max_by_key 相反max_by返回最大值(多个是相同最大值是最后一个)，参数是闭包可以进行筛选(闭包是2个参数)min_by跟 max_by 相反cycle无形循环进行迭代###" } ]
